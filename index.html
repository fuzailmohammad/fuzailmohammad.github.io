<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Complete Mobile Device Scanner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #6dd5ed 100%);
            min-height: 100vh;
            padding: 10px;
            line-height: 1.5;
            font-size: 14px;
            overflow-x: hidden;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(20px);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.8em;
            font-weight: 600;
        }

        .summary-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .device-type {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .fingerprint-id {
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-top: 15px;
        }

        .info-section {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #667eea;
            transition: all 0.3s ease;
        }

        .info-section:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
        }

        .section-title {
            font-size: 1.1em;
            color: #2c3e50;
            margin-bottom: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .icon {
            font-size: 1.2em;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 6px 0;
            border-bottom: 1px solid #f8f9fa;
            gap: 10px;
        }

        .info-item:last-child {
            border-bottom: none;
        }

        .label {
            font-weight: 600;
            color: #495057;
            flex: 1;
            font-size: 0.9em;
        }

        .value {
            color: #212529;
            flex: 1.5;
            text-align: right;
            font-size: 0.9em;
            word-break: break-word;
        }

        .status-online { color: #28a745; }
        .status-offline { color: #dc3545; }
        .fingerprint-hash {
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            background: #f8f9fa;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .permission-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
            margin-top: 5px;
        }

        .permission-btn:hover {
            transform: scale(1.05);
        }

        .refresh-btn {
            width: 100%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            margin: 20px 0;
            transition: all 0.3s ease;
        }

        .refresh-btn:hover {
            transform: translateY(-2px);
        }

        .export-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .export-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .export-btn:hover {
            background: #218838;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            margin: 15px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.3s ease;
        }

        .live-data {
            background: #e8f5e8;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
        }

        .warning {
            background: #fff3cd;
            color: #856404;
            padding: 8px;
            border-radius: 6px;
            font-size: 0.8em;
            margin: 5px 0;
        }

        .canvas-container {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
        }

        .canvas-fingerprint {
            max-width: 100%;
            height: auto;
            border: 1px solid #dee2e6;
            border-radius: 5px;
        }

        @media (min-width: 768px) {
            .container {
                max-width: 900px;
                padding: 30px;
            }
            
            .info-grid {
                grid-template-columns: 1fr 1fr;
            }
            
            .export-section {
                grid-template-columns: repeat(4, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üì± Complete Mobile Device Scanner</h1>
        
        <div class="summary-card">
            <div class="device-type" id="deviceType">Analyzing Device...</div>
            <div id="deviceSummary">Gathering comprehensive device information...</div>
            <div class="fingerprint-id" id="fingerprintDisplay">Generating Device Fingerprint...</div>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progressBar"></div>
        </div>
        
        <div class="info-grid" id="infoGrid">
            <!-- Information sections will be populated here -->
        </div>

        <button class="refresh-btn" onclick="refreshAllInfo()">üîÑ Refresh All Data</button>

        <div class="export-section">
            <button class="export-btn" onclick="exportToJSON()">üìÑ Export JSON</button>
            <button class="export-btn" onclick="copyToClipboard()">üìã Copy Data</button>
            <button class="export-btn" onclick="generateFingerprint()">üîç Fingerprint</button>
            <button class="export-btn" onclick="generateReport()">üìä Report</button>
        </div>
    </div>

    <script>
        let deviceInfo = {};
        let totalSections = 0;
        let completedSections = 0;
        let fingerprintHash = '';

        function updateProgress() {
            completedSections++;
            const progress = (completedSections / totalSections) * 100;
            document.getElementById('progressBar').style.width = progress + '%';
        }

        function createSection(title, icon, items, liveData = null) {
            const section = document.createElement('div');
            section.className = 'info-section';
            
            let itemsHTML = '';
            for (const [key, value] of Object.entries(items)) {
                const isHash = key.includes('Hash') || key.includes('Fingerprint');
                const valueClass = isHash ? 'fingerprint-hash' : '';
                itemsHTML += `
                    <div class="info-item">
                        <span class="label">${key}</span>
                        <span class="value ${valueClass}">${value}</span>
                    </div>
                `;
            }

            if (liveData) {
                itemsHTML += `<div class="live-data" id="${liveData.id}">${liveData.content}</div>`;
            }

            section.innerHTML = `
                <div class="section-title">
                    <span class="icon">${icon}</span>
                    ${title}
                </div>
                ${itemsHTML}
            `;

            return section;
        }

        function hashString(str) {
            let hash = 0;
            if (str.length === 0) return hash.toString(16);
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash).toString(16);
        }

        function detectMobileOS() {
            const ua = navigator.userAgent;
            if (/android/i.test(ua)) return { os: 'Android', version: getAndroidVersion(ua) };
            if (/iPad|iPhone|iPod/.test(ua)) return { os: 'iOS', version: getiOSVersion(ua) };
            if (/Windows Phone/.test(ua)) return { os: 'Windows Phone', version: 'Unknown' };
            if (/BlackBerry/.test(ua)) return { os: 'BlackBerry', version: 'Unknown' };
            return { os: 'Unknown', version: 'Unknown' };
        }

        function getAndroidVersion(ua) {
            const match = ua.match(/Android\s([0-9\.]*)/);
            return match ? match[1] : 'Unknown';
        }

        function getiOSVersion(ua) {
            const match = ua.match(/OS (\d+)_(\d+)_?(\d+)?/);
            return match ? `${match[1]}.${match[2]}.${match[3] || '0'}` : 'Unknown';
        }

        function detectDeviceType() {
            const ua = navigator.userAgent;
            const screenWidth = screen.width;
            
            if (/iPad/.test(ua) || (screenWidth >= 768 && screenWidth <= 1024)) return 'Tablet';
            if (/iPhone|Android.*Mobile|Windows Phone|BlackBerry/.test(ua)) return 'Smartphone';
            if (screenWidth <= 480) return 'Small Phone';
            if (screenWidth <= 768) return 'Large Phone';
            return 'Desktop/Unknown';
        }

        async function getMobileSystemInfo() {
            try {
                const mobileOS = detectMobileOS();
                const deviceType = detectDeviceType();
                
                const info = {
                    'Device Type': deviceType,
                    'Operating System': mobileOS.os,
                    'OS Version': mobileOS.version,
                    'User Agent': navigator.userAgent,
                    'Platform': navigator.platform,
                    'App Name': navigator.appName,
                    'App Version': navigator.appVersion,
                    'Product': navigator.product || 'N/A',
                    'Vendor': navigator.vendor || 'N/A',
                    'Language': navigator.language,
                    'Languages': navigator.languages?.join(', ') || 'N/A',
                    'Timezone': Intl.DateTimeFormat().resolvedOptions().timeZone,
                    'Timezone Offset': `UTC${new Date().getTimezoneOffset() > 0 ? '-' : '+'}${Math.abs(new Date().getTimezoneOffset() / 60)}`
                };

                // Update summary
                document.getElementById('deviceType').textContent = `${deviceType} - ${mobileOS.os}`;
                document.getElementById('deviceSummary').textContent = `${mobileOS.os} ${mobileOS.version} ‚Ä¢ ${screen.width}√ó${screen.height}`;

                deviceInfo.system = info;
                return createSection('System Information', 'üì±', info);
            } catch (e) {
                console.error('System info error:', e);
                return createSection('System Information', 'üì±', {'Error': e.message});
            }
        }

        async function getMobileScreenInfo() {
            try {
                const info = {
                    'Screen Width': `${screen.width}px`,
                    'Screen Height': `${screen.height}px`,
                    'Available Width': `${screen.availWidth}px`,
                    'Available Height': `${screen.availHeight}px`,
                    'Device Pixel Ratio': window.devicePixelRatio || 1,
                    'Physical Width': `${Math.round(screen.width / window.devicePixelRatio)}px`,
                    'Physical Height': `${Math.round(screen.height / window.devicePixelRatio)}px`,
                    'Color Depth': `${screen.colorDepth} bits`,
                    'Pixel Depth': `${screen.pixelDepth} bits`,
                    'Viewport Width': `${window.innerWidth}px`,
                    'Viewport Height': `${window.innerHeight}px`,
                    'Visual Viewport Width': window.visualViewport?.width || 'N/A',
                    'Visual Viewport Height': window.visualViewport?.height || 'N/A',
                    'Orientation Type': screen.orientation?.type || 'N/A',
                    'Orientation Angle': `${screen.orientation?.angle || 0}¬∞`
                };

                // Add HDR detection
                if (window.matchMedia) {
                    info['HDR Support'] = window.matchMedia('(color-gamut: p3)').matches ? 'Yes' : 'No';
                }

                deviceInfo.screen = info;
                return createSection('Screen & Display', 'üñ•Ô∏è', info);
            } catch (e) {
                console.error('Screen info error:', e);
                return createSection('Screen & Display', 'üñ•Ô∏è', {'Error': e.message});
            }
        }

        async function getMobileTouchInfo() {
            try {
                const info = {
                    'Max Touch Points': navigator.maxTouchPoints || 0,
                    'Touch Support': 'ontouchstart' in window ? 'Yes' : 'No',
                    'Pointer Events': 'onpointerdown' in window ? 'Yes' : 'No',
                    'Multi-touch': navigator.maxTouchPoints > 1 ? 'Yes' : 'No',
                    'Force Touch': 'TouchEvent' in window && TouchEvent.prototype.hasOwnProperty('force') ? 'Yes' : 'No',
                    'Hover Support': window.matchMedia && window.matchMedia('(hover: hover)').matches ? 'Yes' : 'No',
                    'Primary Input': window.matchMedia && window.matchMedia('(pointer: coarse)').matches ? 'Touch' : 'Mouse/Trackpad'
                };

                deviceInfo.touch = info;
                return createSection('Touch & Input', 'üëÜ', info);
            } catch (e) {
                console.error('Touch info error:', e);
                return createSection('Touch & Input', 'üëÜ', {'Error': e.message});
            }
        }

        async function getMobileHardwareInfo() {
            try {
                const info = {
                    'CPU Cores': navigator.hardwareConcurrency || 'Unknown',
                    'Device Memory': navigator.deviceMemory ? `${navigator.deviceMemory} GB` : 'Unknown',
                    'Vibration Support': 'vibrate' in navigator ? 'Yes' : 'No',
                    'Gamepad Support': 'getGamepads' in navigator ? 'Yes' : 'No',
                    'Canvas Support': 'getContext' in document.createElement('canvas') ? 'Yes' : 'No',
                    'WebRTC Support': 'RTCPeerConnection' in window ? 'Yes' : 'No',
                    'WebAssembly': 'WebAssembly' in window ? 'Yes' : 'No'
                };

                // WebGL detection
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (gl) {
                        info['WebGL Support'] = 'Yes';
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        if (debugInfo) {
                            info['GPU Vendor'] = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) || 'Unknown';
                            info['GPU Renderer'] = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) || 'Unknown';
                        }
                    } else {
                        info['WebGL Support'] = 'No';
                    }
                } catch (e) {
                    info['WebGL Support'] = 'Error';
                }

                deviceInfo.hardware = info;
                return createSection('Hardware Capabilities', '‚öôÔ∏è', info);
            } catch (e) {
                console.error('Hardware info error:', e);
                return createSection('Hardware Capabilities', '‚öôÔ∏è', {'Error': e.message});
            }
        }

        async function getMobileNetworkInfo() {
            try {
                const info = {
                    'Online Status': navigator.onLine ? 'Online' : 'Offline',
                    'Connection Type': navigator.connection?.effectiveType || 'Unknown',
                    'Downlink Speed': navigator.connection?.downlink ? `${navigator.connection.downlink} Mbps` : 'Unknown',
                    'RTT (Latency)': navigator.connection?.rtt ? `${navigator.connection.rtt} ms` : 'Unknown',
                    'Save Data Mode': navigator.connection?.saveData ? 'Enabled' : 'Disabled'
                };

                // Try to get IP info with timeout
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 5000);
                    
                    const ipResponse = await fetch('https://api.ipify.org?format=json', {
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    
                    const ipData = await ipResponse.json();
                    info['Public IP'] = ipData.ip;
                } catch (e) {
                    info['Public IP'] = 'Unable to fetch';
                }

                deviceInfo.network = info;
                return createSection('Network Information', 'üì∂', info);
            } catch (e) {
                console.error('Network info error:', e);
                return createSection('Network Information', 'üì∂', {'Error': e.message});
            }
        }

        async function getMobileSensorsInfo() {
            try {
                const info = {
                    'Device Motion': 'DeviceMotionEvent' in window ? 'Supported' : 'Not supported',
                    'Device Orientation': 'DeviceOrientationEvent' in window ? 'Supported' : 'Not supported',
                    'Ambient Light': 'AmbientLightSensor' in window ? 'Supported' : 'Not supported',
                    'Accelerometer': 'Accelerometer' in window ? 'Supported' : 'Not supported',
                    'Gyroscope': 'Gyroscope' in window ? 'Supported' : 'Not supported',
                    'Magnetometer': 'Magnetometer' in window ? 'Supported' : 'Not supported',
                    'Proximity Sensor': 'ProximitySensor' in window ? 'Supported' : 'Not supported'
                };

                const liveData = {
                    id: 'sensorReadings',
                    content: '<button class="permission-btn" onclick="startSensorReadings()">Start Live Sensors</button>'
                };

                deviceInfo.sensors = info;
                return createSection('Sensors & Motion', 'üß≠', info, liveData);
            } catch (e) {
                console.error('Sensors info error:', e);
                return createSection('Sensors & Motion', 'üß≠', {'Error': e.message});
            }
        }

        function startSensorReadings() {
            const element = document.getElementById('sensorReadings');
            element.innerHTML = 'Requesting sensor access...';

            try {
                if ('DeviceOrientationEvent' in window) {
                    window.addEventListener('deviceorientation', (event) => {
                        const readings = `
                            <strong>Orientation:</strong><br>
                            Œ± (Z-axis): ${event.alpha?.toFixed(1) || 'N/A'}¬∞<br>
                            Œ≤ (X-axis): ${event.beta?.toFixed(1) || 'N/A'}¬∞<br>
                            Œ≥ (Y-axis): ${event.gamma?.toFixed(1) || 'N/A'}¬∞
                        `;
                        element.innerHTML = readings;
                    });
                }

                if ('DeviceMotionEvent' in window) {
                    window.addEventListener('devicemotion', (event) => {
                        const acc = event.acceleration;
                        if (acc) {
                            const readings = `
                                <strong>Acceleration:</strong><br>
                                X: ${acc.x?.toFixed(2) || 'N/A'} m/s¬≤<br>
                                Y: ${acc.y?.toFixed(2) || 'N/A'} m/s¬≤<br>
                                Z: ${acc.z?.toFixed(2) || 'N/A'} m/s¬≤
                            `;
                            element.innerHTML = readings;
                        }
                    });
                }

                setTimeout(() => {
                    if (element.innerHTML === 'Requesting sensor access...') {
                        element.innerHTML = 'No sensor data received. Motion may be restricted on this device.';
                    }
                }, 3000);
            } catch (e) {
                element.innerHTML = `Sensor error: ${e.message}`;
            }
        }

        async function getMobileMediaInfo() {
            try {
                const info = {
                    'Media Devices API': 'mediaDevices' in navigator ? 'Supported' : 'Not supported',
                    'WebRTC': 'RTCPeerConnection' in window ? 'Supported' : 'Not supported',
                    'Screen Capture': 'getDisplayMedia' in (navigator.mediaDevices || {}) ? 'Supported' : 'Not supported'
                };

                if ('mediaDevices' in navigator) {
                    try {
                        const devices = await navigator.mediaDevices.enumerateDevices();
                        const videoInputs = devices.filter(d => d.kind === 'videoinput');
                        const audioInputs = devices.filter(d => d.kind === 'audioinput');
                        const audioOutputs = devices.filter(d => d.kind === 'audiooutput');
                        
                        info['Camera Inputs'] = videoInputs.length.toString();
                        info['Audio Inputs'] = audioInputs.length.toString();
                        info['Audio Outputs'] = audioOutputs.length.toString();
                    } catch (e) {
                        info['Media Devices'] = 'Permission denied';
                    }
                }

                deviceInfo.media = info;
                return createSection('Camera & Media', 'üì∑', info);
            } catch (e) {
                console.error('Media info error:', e);
                return createSection('Camera & Media', 'üì∑', {'Error': e.message});
            }
        }

        async function getMobileBatteryInfo() {
            try {
                const info = {};

                if ('getBattery' in navigator) {
                    try {
                        const battery = await navigator.getBattery();
                        info['Battery Level'] = `${Math.round(battery.level * 100)}%`;
                        info['Charging Status'] = battery.charging ? 'Charging' : 'Not charging';
                        info['Charging Time'] = battery.chargingTime !== Infinity ? `${Math.round(battery.chargingTime / 60)} min` : 'N/A';
                        info['Discharging Time'] = battery.dischargingTime !== Infinity ? `${Math.round(battery.dischargingTime / 60)} min` : 'N/A';
                    } catch (e) {
                        info['Battery API'] = 'Not supported or access denied';
                    }
                } else {
                    info['Battery API'] = 'Not supported on this device';
                }

                deviceInfo.battery = info;
                return createSection('Battery Information', 'üîã', info);
            } catch (e) {
                console.error('Battery info error:', e);
                return createSection('Battery Information', 'üîã', {'Error': e.message});
            }
        }

        async function getMobileStorageInfo() {
            try {
                const info = {
                    'Local Storage': testStorage('localStorage'),
                    'Session Storage': testStorage('sessionStorage'),
                    'IndexedDB': 'indexedDB' in window ? 'Supported' : 'Not supported',
                    'WebSQL': 'openDatabase' in window ? 'Supported (Deprecated)' : 'Not supported',
                    'Cache API': 'caches' in window ? 'Supported' : 'Not supported',
                    'Cookies': navigator.cookieEnabled ? 'Enabled' : 'Disabled'
                };

                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    try {
                        const quota = await navigator.storage.estimate();
                        info['Storage Quota'] = `${(quota.quota / 1024 / 1024 / 1024).toFixed(2)} GB`;
                        info['Storage Used'] = `${(quota.usage / 1024 / 1024).toFixed(2)} MB`;
                        info['Usage Percentage'] = `${((quota.usage / quota.quota) * 100).toFixed(1)}%`;
                    } catch (e) {
                        info['Storage Quota'] = 'Unable to determine';
                    }
                }

                deviceInfo.storage = info;
                return createSection('Storage & Cache', 'üíæ', info);
            } catch (e) {
                console.error('Storage info error:', e);
                return createSection('Storage & Cache', 'üíæ', {'Error': e.message});
            }
        }

        function testStorage(type) {
            try {
                const storage = window[type];
                const testKey = '__test__';
                storage.setItem(testKey, 'test');
                storage.removeItem(testKey);
                return 'Available';
            } catch (e) {
                return 'Not available';
            }
        }

        async function getMobileLocationInfo() {
            try {
                const info = {
                    'Geolocation API': 'geolocation' in navigator ? 'Available' : 'Not available',
                    'Permissions API': 'permissions' in navigator ? 'Supported' : 'Not supported'
                };

                if ('permissions' in navigator) {
                    try {
                        const permission = await navigator.permissions.query({name: 'geolocation'});
                        info['Location Permission'] = permission.state;
                    } catch (e) {
                        info['Location Permission'] = 'Unable to check';
                    }
                }

                deviceInfo.location = info;
                const liveData = {
                    id: 'locationData',
                    content: '<button class="permission-btn" onclick="getCurrentLocation()">Get Current Location</button>'
                };
                
                return createSection('Location Services', 'üìç', info, liveData);
            } catch (e) {
                console.error('Location info error:', e);
                return createSection('Location Services', 'üìç', {'Error': e.message});
            }
        }

        function getCurrentLocation() {
            if ('geolocation' in navigator) {
                const element = document.getElementById('locationData');
                element.innerHTML = 'Getting location...';
                
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const coords = position.coords;
                        element.innerHTML = `
                            <strong>Location Found:</strong><br>
                            Lat: ${coords.latitude.toFixed(6)}<br>
                            Lng: ${coords.longitude.toFixed(6)}<br>
                            Accuracy: ${coords.accuracy.toFixed(0)}m<br>
                            ${coords.altitude ? `Altitude: ${coords.altitude.toFixed(0)}m<br>` : ''}
                            ${coords.speed ? `Speed: ${coords.speed.toFixed(1)} m/s<br>` : ''}
                            Timestamp: ${new Date(position.timestamp).toLocaleTimeString()}
                        `;
                    },
                    (error) => {
                        element.innerHTML = `<span class="warning">Location Error: ${error.message}</span>`;
                    },
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
                );
            }
        }

        async function getMobilePerformanceInfo() {
            try {
                const info = {};

                if ('performance' in window) {
                    const perf = performance;
                    info['Performance API'] = 'Available';
                    
                    if (perf.memory) {
                        info['JS Heap Used'] = `${(perf.memory.usedJSHeapSize / 1024 / 1024).toFixed(1)} MB`;
                        info['JS Heap Total'] = `${(perf.memory.totalJSHeapSize / 1024 / 1024).toFixed(1)} MB`;
                        info['JS Heap Limit'] = `${(perf.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(1)} MB`;
                    }

                    if (perf.timing) {
                        const timing = perf.timing;
                        info['Page Load Time'] = `${timing.loadEventEnd - timing.navigationStart}ms`;
                        info['DNS Lookup'] = `${timing.domainLookupEnd - timing.domainLookupStart}ms`;
                        info['TCP Connection'] = `${timing.connectEnd - timing.connectStart}ms`;
                    }
                }

                deviceInfo.performance = info;
                return createSection('Performance Metrics', '‚ö°', info);
            } catch (e) {
                console.error('Performance info error:', e);
                return createSection('Performance Metrics', '‚ö°', {'Error': e.message});
            }
        }

        async function getMobileSecurityInfo() {
            try {
                const info = {
                    'HTTPS': location.protocol === 'https:' ? 'Yes' : 'No',
                    'Secure Context': window.isSecureContext ? 'Yes' : 'No',
                    'Cross Origin Isolated': window.crossOriginIsolated ? 'Yes' : 'No',
                    'Permissions API': 'permissions' in navigator ? 'Supported' : 'Not supported',
                    'Credential Management': 'credentials' in navigator ? 'Supported' : 'Not supported',
                    'Web Authentication': 'PublicKeyCredential' in window ? 'Supported' : 'Not supported',
                    'Payment Request': 'PaymentRequest' in window ? 'Supported' : 'Not supported',
                    'Notification API': 'Notification' in window ? 'Supported' : 'Not supported'
                };

                if ('Notification' in window) {
                    info['Notification Permission'] = Notification.permission;
                }

                deviceInfo.security = info;
                return createSection('Security & Privacy', 'üîí', info);
            } catch (e) {
                console.error('Security info error:', e);
                return createSection('Security & Privacy', 'üîí', {'Error': e.message});
            }
        }

        async function generateCanvasFingerprint() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 300;
                canvas.height = 150;

                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                
                ctx.fillStyle = '#069';
                ctx.fillText('Device Fingerprint üîç', 2, 15);
                
                ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
                ctx.fillText('Mobile Scanner', 4, 45);

                const dataURL = canvas.toDataURL();
                return hashString(dataURL);
            } catch (e) {
                return 'canvas-error';
            }
        }

        async function getAdvancedFingerprint() {
            try {
                const info = {};

                // Canvas fingerprint
                info['Canvas Hash'] = await generateCanvasFingerprint();

                // Font detection (simplified)
                const testFonts = ['Arial', 'Helvetica', 'Times New Roman', 'Courier New', 'Verdana'];
                const availableFonts = [];
                const testString = 'mmmmmmmmmmlli';
                const testSize = '72px';
                const h = document.body;

                const s = document.createElement('span');
                s.style.fontSize = testSize;
                s.innerHTML = testString;
                s.style.visibility = 'hidden';

                try {
                    s.style.fontFamily = 'serif';
                    h.appendChild(s);
                    const serifWidth = s.offsetWidth;
                    h.removeChild(s);

                    for (const font of testFonts) {
                        s.style.fontFamily = font + ', serif';
                        h.appendChild(s);
                        if (s.offsetWidth !== serifWidth) {
                            availableFonts.push(font);
                        }
                        h.removeChild(s);
                    }
                } catch (e) {
                    // Font detection failed
                }

                info['Font Hash'] = hashString(availableFonts.join(','));
                info['Available Fonts'] = availableFonts.length.toString();

                // Plugin enumeration
                const plugins = [];
                try {
                    for (let i = 0; i < navigator.plugins.length; i++) {
                        plugins.push(navigator.plugins[i].name);
                    }
                } catch (e) {
                    // Plugin enumeration failed
                }
                info['Plugin Hash'] = hashString(plugins.join(','));

                deviceInfo.fingerprint = info;
                return createSection('Advanced Fingerprint', 'üîç', info);
            } catch (e) {
                console.error('Fingerprint error:', e);
                return createSection('Advanced Fingerprint', 'üîç', {'Error': e.message});
            }
        }

        async function getAllDeviceInfo() {
            const grid = document.getElementById('infoGrid');
            grid.innerHTML = '';
            deviceInfo = {};
            completedSections = 0;

            const sections = [
                getMobileSystemInfo,
                getMobileScreenInfo,
                getMobileTouchInfo,
                getMobileHardwareInfo,
                getMobileNetworkInfo,
                getMobileSensorsInfo,
                getMobileMediaInfo,
                getMobileBatteryInfo,
                getMobileStorageInfo,
                getMobileLocationInfo,
                getMobilePerformanceInfo,
                getMobileSecurityInfo,
                getAdvancedFingerprint
            ];

            totalSections = sections.length;

            for (const getSection of sections) {
                try {
                    const section = await getSection();
                    grid.appendChild(section);
                } catch (e) {
                    console.error('Error getting section info:', e);
                }
                updateProgress();
            }

            // Generate master fingerprint
            setTimeout(() => {
                try {
                    const components = [
                        deviceInfo.system?.['User Agent'] || '',
                        deviceInfo.screen?.['Screen Width'] || '',
                        deviceInfo.hardware?.['CPU Cores'] || '',
                        deviceInfo.fingerprint?.['Canvas Hash'] || '',
                        deviceInfo.fingerprint?.['Font Hash'] || '',
                        navigator.platform,
                        new Date().getTimezoneOffset().toString()
                    ];

                    fingerprintHash = hashString(components.filter(c => c).join('|'));
                    document.getElementById('fingerprintDisplay').textContent = `Device ID: ${fingerprintHash.toUpperCase()}`;
                } catch (e) {
                    document.getElementById('fingerprintDisplay').textContent = 'Fingerprint generation complete';
                }
            }, 500);
        }

        function refreshAllInfo() {
            getAllDeviceInfo();
        }

        function exportToJSON() {
            const timestamp = new Date().toISOString();
            const exportData = {
                timestamp,
                fingerprintHash,
                deviceInfo,
                sessionInfo: {
                    userAgent: navigator.userAgent,
                    timestamp: timestamp,
                    url: window.location.href
                }
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', `mobile_device_scan_${timestamp.split('T')[0]}.json`);
            linkElement.click();
        }

        function copyToClipboard() {
            const exportData = {
                timestamp: new Date().toISOString(),
                fingerprintHash,
                deviceInfo
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            
            if (navigator.clipboard) {
                navigator.clipboard.writeText(dataStr).then(() => {
                    alert('Device information copied to clipboard!');
                }).catch(() => {
                    alert('Unable to copy to clipboard');
                });
            } else {
                alert('Clipboard not supported');
            }
        }

        function generateFingerprint() {
            if (fingerprintHash) {
                alert(`Device Fingerprint: ${fingerprintHash.toUpperCase()}\n\nThis unique identifier is based on your device characteristics and can be used to track you across sessions.`);
            } else {
                alert('Fingerprint not ready yet. Please wait for scan to complete.');
            }
        }

        function generateReport() {
            const report = `
MOBILE DEVICE SCAN REPORT
========================

Device Identifier: ${fingerprintHash.toUpperCase()}
Generated: ${new Date().toISOString()}
Device Type: ${deviceInfo.system?.['Device Type'] || 'Unknown'}
Operating System: ${deviceInfo.system?.['Operating System'] || 'Unknown'}

DEVICE CAPABILITIES:
- Screen: ${deviceInfo.screen?.['Screen Width'] || 'Unknown'} √ó ${deviceInfo.screen?.['Screen Height'] || 'Unknown'}
- Touch Points: ${deviceInfo.touch?.['Max Touch Points'] || 'Unknown'}
- CPU Cores: ${deviceInfo.hardware?.['CPU Cores'] || 'Unknown'}
- Memory: ${deviceInfo.hardware?.['Device Memory'] || 'Unknown'}
- Battery: ${deviceInfo.battery?.['Battery Level'] || 'Unknown'}

NETWORK INFO:
- Connection: ${deviceInfo.network?.['Connection Type'] || 'Unknown'}
- IP Address: ${deviceInfo.network?.['Public IP'] || 'Unknown'}

FINGERPRINTING DATA:
- Canvas Hash: ${deviceInfo.fingerprint?.['Canvas Hash'] || 'N/A'}
- Font Hash: ${deviceInfo.fingerprint?.['Font Hash'] || 'N/A'}

Full Technical Data:
${JSON.stringify(deviceInfo, null, 2)}
            `;
            
            const blob = new Blob([report], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `mobile_scan_report_${fingerprintHash || 'unknown'}.txt`;
            a.click();
        }

        // Initialize on page load
        window.addEventListener('load', getAllDeviceInfo);

        // Update on orientation change
        window.addEventListener('orientationchange', () => {
            setTimeout(getAllDeviceInfo, 1000);
        });

        // Update network status
        window.addEventListener('online', () => {
            setTimeout(getAllDeviceInfo, 500);
        });

        window.addEventListener('offline', () => {
            setTimeout(getAllDeviceInfo, 500);
        });
    </script>
</body>
</html>
