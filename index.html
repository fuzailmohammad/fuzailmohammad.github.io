<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Advanced Device Fingerprinting Scanner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #6dd5ed 100%);
            min-height: 100vh;
            padding: 10px;
            line-height: 1.5;
            font-size: 14px;
            overflow-x: hidden;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(20px);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.8em;
            font-weight: 600;
        }

        .privacy-notice {
            background: #fff3cd;
            color: #856404;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 0.9em;
            border-left: 4px solid #ffc107;
        }

        .fingerprint-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .fingerprint-id {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
        }

        .fingerprint-confidence {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-top: 15px;
        }

        .info-section {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #667eea;
            transition: all 0.3s ease;
        }

        .info-section:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
        }

        .section-title {
            font-size: 1.1em;
            color: #2c3e50;
            margin-bottom: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .icon {
            font-size: 1.2em;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 6px 0;
            border-bottom: 1px solid #f8f9fa;
            gap: 10px;
        }

        .info-item:last-child {
            border-bottom: none;
        }

        .label {
            font-weight: 600;
            color: #495057;
            flex: 1;
            font-size: 0.9em;
        }

        .value {
            color: #212529;
            flex: 1.5;
            text-align: right;
            font-size: 0.9em;
            word-break: break-word;
        }

        .fingerprint-hash {
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            background: #f8f9fa;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .stability-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .stable { background-color: #28a745; }
        .semi-stable { background-color: #ffc107; }
        .unstable { background-color: #dc3545; }

        .permission-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
            margin-top: 5px;
        }

        .permission-btn:hover {
            transform: scale(1.05);
        }

        .refresh-btn {
            width: 100%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            margin: 20px 0;
            transition: all 0.3s ease;
        }

        .refresh-btn:hover {
            transform: translateY(-2px);
        }

        .export-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .export-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .export-btn:hover {
            background: #218838;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            margin: 15px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.3s ease;
        }

        .canvas-container {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
        }

        .canvas-fingerprint {
            max-width: 100%;
            height: auto;
            border: 1px solid #dee2e6;
            border-radius: 5px;
        }

        .timing-info {
            background: #e8f5e8;
            padding: 8px;
            border-radius: 6px;
            margin: 5px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
        }

        .warning {
            background: #fff3cd;
            color: #856404;
            padding: 8px;
            border-radius: 6px;
            font-size: 0.8em;
            margin: 5px 0;
        }

        @media (min-width: 768px) {
            .container {
                max-width: 900px;
                padding: 30px;
            }
            
            .info-grid {
                grid-template-columns: 1fr 1fr;
            }
            
            .export-section {
                grid-template-columns: repeat(4, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Advanced Device Fingerprinting Scanner</h1>
        
        <div class="privacy-notice">
            <strong>Privacy Notice:</strong> This tool demonstrates advanced browser fingerprinting techniques. The collected data can uniquely identify your device across sessions and websites. Use responsibly and be aware of privacy implications.
        </div>

        <div class="fingerprint-card">
            <div class="fingerprint-id" id="fingerprintDisplay">Generating Unique Device Fingerprint...</div>
            <div class="fingerprint-confidence" id="confidenceDisplay">Calculating stability score...</div>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progressBar"></div>
        </div>
        
        <div class="info-grid" id="infoGrid">
            <!-- Information sections will be populated here -->
        </div>

        <button class="refresh-btn" onclick="refreshAllInfo()">üîÑ Re-scan Device</button>

        <div class="export-section">
            <button class="export-btn" onclick="exportToJSON()">üìÑ Export JSON</button>
            <button class="export-btn" onclick="copyFingerprint()">üìã Copy ID</button>
            <button class="export-btn" onclick="compareFingerprints()">üîÑ Compare</button>
            <button class="export-btn" onclick="generateReport()">üìä Report</button>
        </div>
    </div>

    <script>
        let deviceFingerprint = {};
        let persistentData = {};
        let totalSections = 0;
        let completedSections = 0;
        let fingerprintHash = '';
        let stabilityScore = 0;

        function updateProgress() {
            completedSections++;
            const progress = (completedSections / totalSections) * 100;
            document.getElementById('progressBar').style.width = progress + '%';
        }

        function createSection(title, icon, items, stability = 'stable') {
            const section = document.createElement('div');
            section.className = 'info-section';
            
            const stabilityClass = stability === 'high' ? 'stable' : stability === 'medium' ? 'semi-stable' : 'unstable';
            
            let itemsHTML = '';
            for (const [key, value] of Object.entries(items)) {
                const isFingerprint = key.includes('Hash') || key.includes('Fingerprint') || key.includes('Signature');
                const valueClass = isFingerprint ? 'fingerprint-hash' : '';
                const stabilityIndicator = `<span class="stability-indicator ${stabilityClass}"></span>`;
                
                itemsHTML += `
                    <div class="info-item">
                        <span class="label">${stabilityIndicator}${key}</span>
                        <span class="value ${valueClass}">${value}</span>
                    </div>
                `;
            }

            section.innerHTML = `
                <div class="section-title">
                    <span class="icon">${icon}</span>
                    ${title}
                </div>
                ${itemsHTML}
            `;

            return section;
        }

        // Canvas Fingerprinting
        function generateCanvasFingerprint() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 300;
            canvas.height = 200;

            // Complex drawing operations for unique fingerprinting
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillStyle = '#f60';
            ctx.fillRect(125, 1, 62, 20);
            
            ctx.fillStyle = '#069';
            ctx.fillText('Device Fingerprint üîç', 2, 15);
            
            ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
            ctx.fillText('Advanced Browser Detection', 4, 45);
            
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = 'rgb(255,0,255)';
            ctx.beginPath();
            ctx.arc(50, 50, 50, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = 'rgb(0,255,255)';
            ctx.beginPath();
            ctx.arc(100, 50, 50, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fill();

            // Add emoji and unicode characters
            ctx.fillStyle = '#000';
            ctx.font = '16px Arial';
            ctx.fillText('üåçüì±üíªüîí', 10, 100);

            const dataURL = canvas.toDataURL();
            return {
                hash: hashString(dataURL),
                dataURL: dataURL,
                canvas: canvas
            };
        }

        // Audio Context Fingerprinting
        async function generateAudioFingerprint() {
            return new Promise((resolve) => {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const analyser = audioContext.createAnalyser();
                    const gainNode = audioContext.createGain();
                    const scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);

                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(10000, audioContext.currentTime);

                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);

                    oscillator.connect(analyser);
                    analyser.connect(scriptProcessor);
                    scriptProcessor.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    scriptProcessor.onaudioprocess = function(bins) {
                        const samples = bins.inputBuffer.getChannelData(0);
                        let sum = 0;
                        for (let i = 0; i < samples.length; i++) {
                            sum += Math.abs(samples[i]);
                        }
                        
                        oscillator.disconnect();
                        scriptProcessor.disconnect();
                        audioContext.close();
                        
                        resolve({
                            hash: hashString(sum.toString()),
                            sum: sum,
                            sampleRate: audioContext.sampleRate,
                            maxChannelCount: audioContext.destination.maxChannelCount,
                            state: audioContext.state
                        });
                    };

                    oscillator.start(0);
                } catch (e) {
                    resolve({ hash: 'unsupported', error: e.message });
                }
            });
        }

        // WebGL Fingerprinting (Enhanced)
        function generateWebGLFingerprint() {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) return { hash: 'unsupported' };

            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            const vendor = debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : gl.getParameter(gl.VENDOR);
            const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : gl.getParameter(gl.RENDERER);
            
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, 'attribute vec2 attrVertex;varying vec2 varyinTexCoordinate;uniform vec2 uniformOffset;void main(){varyinTexCoordinate=attrVertex+uniformOffset;gl_Position=vec4(attrVertex,0,1);}');
            gl.compileShader(vertexShader);

            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, 'precision mediump float;varying vec2 varyinTexCoordinate;void main() {gl_FragColor=vec4(varyinTexCoordinate,0,1);}');
            gl.compileShader(fragmentShader);

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.useProgram(program);

            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-0.2, -0.9, 0, 0.4, -0.26, 0, 0, 0.7321, 0]), gl.STATIC_DRAW);

            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 3);

            const pixels = new Uint8Array(gl.drawingBufferWidth * gl.drawingBufferHeight * 4);
            gl.readPixels(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

            return {
                vendor: vendor,
                renderer: renderer,
                version: gl.getParameter(gl.VERSION),
                shadingLanguageVersion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
                extensions: gl.getSupportedExtensions(),
                pixelHash: hashString(Array.from(pixels).join(''))
            };
        }

        // Font Detection
        function detectFonts() {
            const testFonts = [
                'Arial', 'Helvetica', 'Times New Roman', 'Courier New', 'Verdana', 'Georgia', 'Palatino',
                'Garamond', 'Bookman', 'Tahoma', 'Comic Sans MS', 'Impact', 'Arial Black', 'Helvetica Neue',
                'Lucida Grande', 'Lucida Sans Unicode', 'Trebuchet MS', 'Microsoft Sans Serif', 'Segoe UI',
                'Roboto', 'Droid Sans', 'Ubuntu', 'Cantarell', 'DejaVu Sans', 'Liberation Sans',
                'Noto Sans', 'Source Sans Pro', 'Open Sans', 'Lato', 'Montserrat', 'Raleway',
                'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', 'Android Emoji'
            ];

            const baseFonts = ['serif', 'sans-serif', 'monospace'];
            const testString = 'mmmmmmmmmmlli';
            const testSize = '72px';
            const h = document.getElementsByTagName('body')[0];

            const s = document.createElement('span');
            s.style.fontSize = testSize;
            s.innerHTML = testString;
            const defaultWidths = {};
            const defaultHeights = {};

            for (let i = 0; i < baseFonts.length; i++) {
                s.style.fontFamily = baseFonts[i];
                h.appendChild(s);
                defaultWidths[baseFonts[i]] = s.offsetWidth;
                defaultHeights[baseFonts[i]] = s.offsetHeight;
                h.removeChild(s);
            }

            const detectedFonts = [];
            for (let i = 0; i < testFonts.length; i++) {
                let detected = false;
                for (let j = 0; j < baseFonts.length; j++) {
                    s.style.fontFamily = testFonts[i] + ',' + baseFonts[j];
                    h.appendChild(s);
                    const matched = (s.offsetWidth !== defaultWidths[baseFonts[j]] || s.offsetHeight !== defaultHeights[baseFonts[j]]);
                    h.removeChild(s);
                    detected = detected || matched;
                }
                if (detected) {
                    detectedFonts.push(testFonts[i]);
                }
            }

            return detectedFonts;
        }

        // Plugin Detection
        function detectPlugins() {
            const plugins = [];
            for (let i = 0; i < navigator.plugins.length; i++) {
                const plugin = navigator.plugins[i];
                plugins.push({
                    name: plugin.name,
                    filename: plugin.filename,
                    description: plugin.description,
                    version: plugin.version || 'Unknown'
                });
            }
            return plugins;
        }

        // Timing Attack for CPU Fingerprinting
        function getCPUFingerprint() {
            const start = performance.now();
            let count = 0;
            
            // CPU-intensive operation
            for (let i = 0; i < 100000; i++) {
                count += Math.random() * Math.random();
            }
            
            const end = performance.now();
            const duration = end - start;
            
            // Memory allocation pattern
            const arrays = [];
            const memStart = performance.now();
            for (let i = 0; i < 1000; i++) {
                arrays.push(new Array(1000).fill(Math.random()));
            }
            const memEnd = performance.now();
            
            return {
                computeTime: Math.round(duration * 1000) / 1000,
                memoryTime: Math.round((memEnd - memStart) * 1000) / 1000,
                hardwareConcurrency: navigator.hardwareConcurrency || 1,
                deviceMemory: navigator.deviceMemory || 'Unknown'
            };
        }

        // Mouse/Touch Behavior Fingerprinting
        function initializeBehaviorTracking() {
            let mouseMovements = [];
            let touchPatterns = [];
            let keyboardTimings = [];

            document.addEventListener('mousemove', (e) => {
                mouseMovements.push({
                    x: e.clientX,
                    y: e.clientY,
                    time: Date.now()
                });
                if (mouseMovements.length > 10) mouseMovements.shift();
            });

            document.addEventListener('touchmove', (e) => {
                const touch = e.touches[0];
                touchPatterns.push({
                    x: touch.clientX,
                    y: touch.clientY,
                    pressure: touch.force || 0,
                    time: Date.now()
                });
                if (touchPatterns.length > 10) touchPatterns.shift();
            });

            let lastKeyTime = 0;
            document.addEventListener('keydown', (e) => {
                const now = Date.now();
                if (lastKeyTime > 0) {
                    keyboardTimings.push(now - lastKeyTime);
                    if (keyboardTimings.length > 10) keyboardTimings.shift();
                }
                lastKeyTime = now;
            });

            return {
                getMousePattern: () => mouseMovements,
                getTouchPattern: () => touchPatterns,
                getKeyboardPattern: () => keyboardTimings
            };
        }

        // Advanced Hardware Detection
        async function getAdvancedHardwareInfo() {
            const info = {
                'CPU Cores': navigator.hardwareConcurrency || 'Unknown',
                'Device Memory': navigator.deviceMemory ? `${navigator.deviceMemory} GB` : 'Unknown',
                'Connection Type': navigator.connection?.effectiveType || 'Unknown',
                'Platform': navigator.platform,
                'Architecture': navigator.platform.includes('64') ? '64-bit' : '32-bit',
                'Max Touch Points': navigator.maxTouchPoints || 0
            };

            // CPU Performance fingerprint
            const cpuInfo = getCPUFingerprint();
            info['CPU Performance'] = `${cpuInfo.computeTime}ms`;
            info['Memory Performance'] = `${cpuInfo.memoryTime}ms`;

            // WebGL capabilities
            const webglInfo = generateWebGLFingerprint();
            info['GPU Vendor'] = webglInfo.vendor || 'Unknown';
            info['GPU Renderer'] = webglInfo.renderer || 'Unknown';
            info['WebGL Hash'] = webglInfo.pixelHash || 'N/A';

            deviceFingerprint.hardware = info;
            return createSection('Hardware Fingerprint', '‚öôÔ∏è', info, 'high');
        }

        // Browser Fingerprinting
        async function getBrowserFingerprint() {
            const info = {
                'User Agent': navigator.userAgent,
                'Platform': navigator.platform,
                'Language': navigator.language,
                'Languages': navigator.languages?.join(', ') || 'N/A',
                'Timezone': Intl.DateTimeFormat().resolvedOptions().timeZone,
                'Do Not Track': navigator.doNotTrack || 'Not set',
                'Cookies Enabled': navigator.cookieEnabled ? 'Yes' : 'No'
            };

            // Detect installed fonts
            const fonts = detectFonts();
            info['Installed Fonts'] = fonts.length.toString();
            info['Font Hash'] = hashString(fonts.join(','));

            // Plugin detection
            const plugins = detectPlugins();
            info['Plugins Count'] = plugins.length.toString();
            info['Plugin Hash'] = hashString(plugins.map(p => p.name).join(','));

            deviceFingerprint.browser = info;
            return createSection('Browser Fingerprint', 'üåê', info, 'high');
        }

        // Canvas & Audio Fingerprinting
        async function getCanvasAudioFingerprint() {
            const canvasInfo = generateCanvasFingerprint();
            const audioInfo = await generateAudioFingerprint();

            const info = {
                'Canvas Hash': canvasInfo.hash,
                'Audio Hash': audioInfo.hash,
                'Audio Sample Rate': audioInfo.sampleRate || 'N/A',
                'Audio Channels': audioInfo.maxChannelCount || 'N/A'
            };

            // Display canvas image
            const canvasContainer = document.createElement('div');
            canvasContainer.className = 'canvas-container';
            canvasContainer.innerHTML = `
                <div style="font-size: 0.8em; margin-bottom: 5px;">Canvas Fingerprint Image:</div>
            `;
            canvasContainer.appendChild(canvasInfo.canvas);

            deviceFingerprint.canvas = info;
            const section = createSection('Canvas & Audio', 'üé®', info, 'high');
            section.appendChild(canvasContainer);
            return section;
        }

        // Screen & Display Advanced
        async function getAdvancedScreenInfo() {
            const info = {
                'Screen Resolution': `${screen.width}√ó${screen.height}`,
                'Available Resolution': `${screen.availWidth}√ó${screen.availHeight}`,
                'Color Depth': `${screen.colorDepth} bits`,
                'Pixel Ratio': window.devicePixelRatio || 1,
                'Orientation': screen.orientation?.type || 'Unknown'
            };

            // Detect HDR support
            if (window.matchMedia) {
                info['HDR Support'] = window.matchMedia('(color-gamut: p3)').matches ? 'Yes' : 'No';
                info['High Refresh Rate'] = window.matchMedia('(prefers-reduced-motion: no-preference)').matches ? 'Supported' : 'Limited';
            }

            // Calculate estimated PPI
            const diagonal = Math.sqrt(screen.width ** 2 + screen.height ** 2);
            const estimatedSize = diagonal < 1000 ? 5 : diagonal < 1500 ? 6 : diagonal < 2000 ? 7 : 10;
            info['Estimated PPI'] = Math.round(diagonal / estimatedSize);

            deviceFingerprint.screen = info;
            return createSection('Display Fingerprint', 'üì∫', info, 'high');
        }

        // Network & Location Advanced
        async function getNetworkLocationFingerprint() {
            const info = {
                'Online Status': navigator.onLine ? 'Online' : 'Offline',
                'Connection Type': navigator.connection?.effectiveType || 'Unknown',
                'Save Data': navigator.connection?.saveData ? 'Enabled' : 'Disabled'
            };

            // Try to get WebRTC IP leak
            try {
                const ips = await getWebRTCIPs();
                info['Local IPs'] = ips.join(', ') || 'Not detected';
            } catch (e) {
                info['Local IPs'] = 'WebRTC blocked';
            }

            // Get public IP and location
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                info['Public IP'] = data.ip;

                // Get ISP info
                const locationResponse = await fetch(`https://ipapi.co/${data.ip}/json/`);
                const locationData = await locationResponse.json();
                info['ISP'] = locationData.org || 'Unknown';
                info['Country'] = locationData.country_name || 'Unknown';
                info['City'] = locationData.city || 'Unknown';
            } catch (e) {
                info['Network Info'] = 'Unable to fetch';
            }

            deviceFingerprint.network = info;
            return createSection('Network Fingerprint', 'üåç', info, 'medium');
        }

        // WebRTC IP Detection
        function getWebRTCIPs() {
            return new Promise((resolve) => {
                const ips = [];
                const RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
                
                if (!RTCPeerConnection) {
                    resolve([]);
                    return;
                }

                const pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });

                pc.createDataChannel('');
                pc.createOffer().then(offer => pc.setLocalDescription(offer));

                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        const ip = event.candidate.candidate.match(/\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b/);
                        if (ip && !ips.includes(ip[0])) {
                            ips.push(ip[0]);
                        }
                    }
                };

                setTimeout(() => {
                    pc.close();
                    resolve(ips);
                }, 2000);
            });
        }

        // Storage & Persistence
        async function getStoragePersistenceInfo() {
            const info = {};

            // Check storage persistence
            if ('storage' in navigator && 'persist' in navigator.storage) {
                try {
                    info['Storage Persistent'] = await navigator.storage.persist() ? 'Yes' : 'No';
                    const estimate = await navigator.storage.estimate();
                    info['Storage Quota'] = `${(estimate.quota / 1024 / 1024 / 1024).toFixed(2)} GB`;
                    info['Storage Used'] = `${(estimate.usage / 1024 / 1024).toFixed(2)} MB`;
                } catch (e) {
                    info['Storage API'] = 'Access denied';
                }
            } else {
                info['Storage API'] = 'Not supported';
            }

            // Test various storage mechanisms
            info['localStorage'] = testStorageAPI('localStorage');
            info['sessionStorage'] = testStorageAPI('sessionStorage');
            info['IndexedDB'] = 'indexedDB' in window ? 'Supported' : 'Not supported';

            // Try to set/get persistent data
            try {
                const testKey = '_fingerprint_test_';
                localStorage.setItem(testKey, Date.now().toString());
                const stored = localStorage.getItem(testKey);
                info['Persistence Test'] = stored ? 'Working' : 'Failed';
                localStorage.removeItem(testKey);
            } catch (e) {
                info['Persistence Test'] = 'Blocked';
            }

            deviceFingerprint.storage = info;
            return createSection('Storage & Persistence', 'üíæ', info, 'medium');
        }

        function testStorageAPI(apiName) {
            try {
                const storage = window[apiName];
                const testKey = '__test__';
                storage.setItem(testKey, 'test');
                storage.removeItem(testKey);
                return 'Available';
            } catch (e) {
                return 'Blocked/Full';
            }
        }

        // Performance & Timing
        async function getPerformanceFingerprint() {
            const info = {};

            if ('performance' in window) {
                const perf = performance;
                
                // High-resolution timing
                const start = perf.now();
                for (let i = 0; i < 1000; i++) {
                    Math.random();
                }
                const end = perf.now();
                info['CPU Timing'] = `${(end - start).toFixed(3)}ms`;

                // Memory info
                if (perf.memory) {
                    info['JS Heap Used'] = `${(perf.memory.usedJSHeapSize / 1024 / 1024).toFixed(1)} MB`;
                    info['JS Heap Total'] = `${(perf.memory.totalJSHeapSize / 1024 / 1024).toFixed(1)} MB`;
                    info['JS Heap Limit'] = `${(perf.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(1)} MB`;
                }

                // Navigation timing
                if (perf.timing) {
                    const nav = perf.timing;
                    info['Page Load'] = `${nav.loadEventEnd - nav.navigationStart}ms`;
                    info['DNS Lookup'] = `${nav.domainLookupEnd - nav.domainLookupStart}ms`;
                    info['TCP Connect'] = `${nav.connectEnd - nav.connectStart}ms`;
                }
            }

            deviceFingerprint.performance = info;
            return createSection('Performance Timing', '‚ö°', info, 'medium');
        }

        // Generate comprehensive fingerprint
        function generateMasterFingerprint() {
            const components = [
                deviceFingerprint.hardware?.['CPU Performance'] || '',
                deviceFingerprint.browser?.['Font Hash'] || '',
                deviceFingerprint.canvas?.['Canvas Hash'] || '',
                deviceFingerprint.canvas?.['Audio Hash'] || '',
                deviceFingerprint.screen?.['Screen Resolution'] || '',
                deviceFingerprint.network?.['Public IP'] || '',
                navigator.userAgent,
                navigator.platform,
                screen.width + 'x' + screen.height,
                new Date().getTimezoneOffset().toString()
            ];

            const masterString = components.filter(c => c).join('|');
            const hash = hashString(masterString);
            
            // Calculate stability score
            const stableComponents = [
                'hardware', 'browser', 'canvas', 'screen'
            ];
            
            let stableCount = 0;
            stableComponents.forEach(comp => {
                if (deviceFingerprint[comp]) stableCount++;
            });
            
            stabilityScore = Math.round((stableCount / stableComponents.length) * 100);
            
            return {
                hash: hash,
                components: components.length,
                stability: stabilityScore
            };
        }

        // Simple hash function
        function hashString(str) {
            let hash = 0;
            if (str.length === 0) return hash.toString(16);
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return Math.abs(hash).toString(16);
        }

        // Main scanning function
        async function getAllDeviceInfo() {
            const grid = document.getElementById('infoGrid');
            grid.innerHTML = '';
            deviceFingerprint = {};
            completedSections = 0;

            const sections = [
                getAdvancedHardwareInfo,
                getBrowserFingerprint,
                getCanvasAudioFingerprint,
                getAdvancedScreenInfo,
                getNetworkLocationFingerprint,
                getStoragePersistenceInfo,
                getPerformanceFingerprint
            ];

            totalSections = sections.length;

            for (const getSection of sections) {
                try {
                    const section = await getSection();
                    grid.appendChild(section);
                } catch (e) {
                    console.error('Error getting section info:', e);
                }
                updateProgress();
            }

            // Generate master fingerprint
            const masterFingerprint = generateMasterFingerprint();
            fingerprintHash = masterFingerprint.hash;
            
            document.getElementById('fingerprintDisplay').textContent = `Device ID: ${fingerprintHash.toUpperCase()}`;
            document.getElementById('confidenceDisplay').textContent = `Stability Score: ${stabilityScore}% ‚Ä¢ ${masterFingerprint.components} data points`;

            // Initialize behavior tracking
            initializeBehaviorTracking();
        }

        function refreshAllInfo() {
            getAllDeviceInfo();
        }

        function exportToJSON() {
            const timestamp = new Date().toISOString();
            const exportData = {
                timestamp,
                fingerprintHash,
                stabilityScore,
                deviceFingerprint,
                sessionInfo: {
                    userAgent: navigator.userAgent,
                    timestamp: timestamp,
                    url: window.location.href
                }
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', `device_fingerprint_${fingerprintHash}_${timestamp.split('T')[0]}.json`);
            linkElement.click();
        }

        function copyFingerprint() {
            const fingerprintData = `Device Fingerprint: ${fingerprintHash.toUpperCase()}\nStability: ${stabilityScore}%\nGenerated: ${new Date().toISOString()}`;
            
            if (navigator.clipboard) {
                navigator.clipboard.writeText(fingerprintData).then(() => {
                    alert('Device fingerprint copied to clipboard!');
                });
            } else {
                alert(`Device ID: ${fingerprintHash.toUpperCase()}`);
            }
        }

        function compareFingerprints() {
            const stored = localStorage.getItem('_device_fingerprint_history_');
            let history = stored ? JSON.parse(stored) : [];
            
            const current = {
                hash: fingerprintHash,
                timestamp: new Date().toISOString(),
                stability: stabilityScore
            };
            
            history.push(current);
            if (history.length > 10) history.shift(); // Keep last 10
            
            localStorage.setItem('_device_fingerprint_history_', JSON.stringify(history));
            
            const matches = history.filter(h => h.hash === fingerprintHash).length;
            alert(`Fingerprint History:\nCurrent ID: ${fingerprintHash.toUpperCase()}\nMatches in history: ${matches}/${history.length}\nFirst seen: ${history[0]?.timestamp || 'Now'}`);
        }

        function generateReport() {
            const report = `
DEVICE FINGERPRINTING REPORT
============================

Device Identifier: ${fingerprintHash.toUpperCase()}
Stability Score: ${stabilityScore}%
Generated: ${new Date().toISOString()}

FINGERPRINT COMPONENTS:
- Hardware fingerprint (CPU, GPU, Memory)
- Canvas rendering signature
- Audio context fingerprint
- Font enumeration
- WebGL capabilities
- Screen characteristics
- Network information
- Browser configuration

PRIVACY IMPLICATIONS:
This fingerprint can potentially track you across:
- Different websites
- Private/incognito browsing sessions
- After clearing cookies
- Even with VPN usage

PROTECTION RECOMMENDATIONS:
- Use browsers with fingerprinting protection
- Enable privacy-focused browser extensions
- Consider using Tor browser for sensitive browsing
- Regularly update browser and OS
- Use different browsers for different activities

Technical Details: ${JSON.stringify(deviceFingerprint, null, 2)}
            `;
            
            const blob = new Blob([report], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `fingerprint_report_${fingerprintHash}.txt`;
            a.click();
        }

        // Initialize on page load
        window.addEventListener('load', getAllDeviceInfo);
    </script>
</body>
</html>
